---
blogid: jugaad-oriented-programming
date: 02/03/2024
---

Recently at work, I was assigned to solve a bug that had been lingering for a while. We were plotting a chart and needed to highlight the highest peak using D3.js. The values for the chart came from a different service, which, according to the team responsible, had been thoroughly tested. Yet, when the values were plotted by that service, the peaks were highlighted correctly. However, when the same data was passed over to our UI that used D3.js, the plot was wrong. Same values. Different results. **How?**

This service was owned by a completely different team, and their data and codebase were large and complex. My task was to identify the root cause of the inconsistency, and I needed proof before I could move forward.

### The Possibilities

Initially, two thoughts crossed my mind:

1. Maybe the issue was with our plotting engine in the UI.
2. Perhaps the data being sent to us was incorrect (though the service team insisted it was fine).

I quickly began to rule out the first possibility. Our D3.js plotting engine worked perfectly for other cases—it only failed in certain scenarios, which made me think the issue wasn’t entirely on our end. This led me to focus on the second possibility. However, digging into this would require setting up the entire system locally. That meant getting a database snapshot, configuring everything properly, and making sure I had all the required permissions (we use RBAC). While this should ideally take a few minutes, in the corporate world, minutes can easily turn into hours or even days.

### Thinking Outside the Box

At this point, I could have simply proven that the data was wrong, escalated the issue to the service team, and washed my hands of it. But instead, I decided to explore a more direct way to prove my hypothesis. I requested an environment where I could reproduce the bug and dove into the network call responsible for fetching the data from the service. I copied the x and y coordinates that the service was sending, wrote a quick Python script, and plotted the data myself.

My goal was simple: if the chart generated by my Python script looked identical to the D3.js chart, then the data was indeed incorrect. And guess what? Both graphs matched perfectly, confirming that the service was sending flawed data. I presented this proof to the service team and, as a result, removed three long-standing bugs (some more than 25 days old!) from my team's sprint board.

### The Takeaway

I know this solution isn’t groundbreaking, nor did I fix the core problem. But what excited me was that a bit of thinking outside the box led to a clear solution. I felt proud—not because I did something revolutionary, but because I approached the problem with a **jugaad** mindset.

**Jugaad** is an Indian term for an innovative, flexible approach to solving a problem with limited resources. It’s not about finding the perfect solution; it’s about finding _a_ solution that works—and works now. Sometimes, putting jugaad first saves you time and energy while moving the needle forward.

In the end, this experience reminded me that programming is as much about creativity as it is about code.
